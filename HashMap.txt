java集合包
HashMap底层的数据结构是什么？

数组

JDK 1.8中对hash算法和寻址算法是如何优化的？

hash算法
先通过二进制运算得到一个二进制值a，然后位运算向右偏移16位，高16位用0补齐，得到新的二进制值b
然后新的值和旧进行异或运算，得到一个新的二进制值c，最后把这个c转换为一个int值32位就是最后的hash值了

例如：假设
a为：1111 1111 1111 1111 1111 1010 0111 1100
进行位运算向右偏移16位，得到
b为：0000 0000 0000 0000 1111 1111 1111 1111
然后再进行异或运算得到
c为：1111 1111 1111 1111 0000 0101 1000 0011

代码如下（HashMap JDK1.8的337行位置）：
	static final int hash(Object key) {
        int h;
        return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
    }


hash算法的优化：对于每个hash值，在他的低16位中，让高低16位进行了异或，让他的低16位同时保持了高低16位的特征，尽量避免一些hash值后续出现冲突，
寻址算法的优化：用运算代替取模，提升性能


HashMap是如何解决hash碰撞问题？
hash冲突问题，链表+红黑树，O(n)和O(logn)

多个key算出来的hash值，与n-1，与运算后发现定位出来的数组位置还是一样的，就会发现hash冲突。
会在冲突的位置形成一个链表结构，get的时候就需要遍历这个链表，当链表达到一定长度后遍历就比较慢时间复杂度O(n)，
达到一定长度后就会转为红黑树的结构，遍历一颗红黑树找一个元素时间复杂度O(logn)。性能会比链表高一些。




HashMap是如何进行扩容的？

底层是一个数组，当这个数组满了，会自动扩容进行2倍的扩容。





