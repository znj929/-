###java集合包
#### HashMap底层的数据结构是什么？

数组+链表 红黑树

#### HashMap的put()和get()的实现

````

````




#### 为什么要转红黑树？

当链表长度超过阈值（8）时，将链表转换为红黑树,
链表查找元素的时间复杂度为 O(n)，远远大于红黑树的 O(logn)，尤其是在节点越来越多的情况下，O(logn) 体现出的优势会更加明显；简而言之就是为了提升查询的效率。

#### 为什么不一开始就用红黑树？
````
JDK 的源码注释中已经对这个问题作了解释：
单个 TreeNode 需要占用的空间大约是普通 Node 的两倍，所以只有当包含足够多的 Nodes 时才会转成 TreeNodes，而是否足够多就是由 TREEIFY_THRESHOLD 的值（默认值8）决定的。
而当桶中节点数由于移除或者 resize 变少后，又会变回普通的链表的形式，以便节省空间，这个阈值是 UNTREEIFY_THRESHOLD（默认值6）。


````
#### 转换阈值 8 是怎么来的？
````
在源码中也对选择 8 这个数字做了说明:

链表长度超过 8 就转为红黑树的设计，更多的是为了防止用户自己实现了不好的哈希算法时导致链表过长，从而导致查询效率低，而此时转为红黑树更多的是一种保底策略，用来保证极端情况下查询的效率。

如果 hashCode 分布良好，也就是 hash 计算的结果离散好的话，那么红黑树这种形式是很少会被用到的，因为各个值都均匀分布，很少出现链表很长的情况。在理想情况下，链表长度符合泊松分布，
各个长度的命中概率依次递减，当长度为 8 的时候，概率仅为 0.00000006。这是一个小于千万分之一的概率，通常我们的 Map 里面是不会存储这么多的数据的，
所以通常情况下，并不会发生从链表向红黑树的转换。

````


#### JDK 1.8中对hash算法和寻址算法是如何优化的？

hash算法
先通过二进制运算得到一个二进制值a，然后位运算向右偏移16位，高16位用0补齐，得到新的二进制值b
然后新的值和旧进行异或运算，得到一个新的二进制值c，最后把这个c转换为一个int值32位就是最后的hash值了

例如：假设
a为：1111 1111 1111 1111 1111 1010 0111 1100
进行位运算向右偏移16位，得到
b为：0000 0000 0000 0000 1111 1111 1111 1111
然后再进行异或运算得到
c为：1111 1111 1111 1111 0000 0101 1000 0011

代码如下（HashMap JDK1.8的337行位置）：
	static final int hash(Object key) {
        int h;
        return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
    }


hash算法的优化：对于每个hash值，在他的低16位中，让高低16位进行了异或，让他的低16位同时保持了高低16位的特征，尽量避免一些hash值后续出现冲突，
寻址算法的优化：用运算代替取模，提升性能


#### HashMap是如何解决hash碰撞问题？
hash冲突问题，链表+红黑树，O(n)和O(logn)

多个key算出来的hash值，与n-1，与运算后发现定位出来的数组位置还是一样的，就会发现hash冲突。
会在冲突的位置形成一个链表结构，get的时候就需要遍历这个链表，当链表达到一定长度后遍历就比较慢时间复杂度O(n)，
达到一定长度后就会转为红黑树的结构，遍历一颗红黑树找一个元素时间复杂度O(logn)。性能会比链表高一些。

#### HashMap是如何进行扩容的？

底层是一个数组，当这个数组到达扩容阈值，会自动扩容进行扩容。
注意：
阈值(threshold) = 负载因子(loadFactor) x 容量(capacity) 
当HashMap中table数组(也称为桶)长度 >= 阈值(threshold) 就会自动进行扩容。

扩容的规则是这样的，因为table数组长度必须是2的次方数，扩容其实每次都是按照上一次tableSize位运算得到的就是做一次左移1位运算，
假设当前tableSize是16的话 16转为二进制再向左移一位就得到了32 即 16 << 1 == 32 即扩容后的容量，也就是说扩容后的容量是当前
容量的两倍，但记住HashMap的扩容是采用当前容量向左位移一位（newtableSize = tableSize << 1），得到的扩容后容量，而不是当前容量x2


#### 为什么计算扩容后容量要采用位移运算呢，怎么不直接乘以2呢？
因为cpu毕竟它不支持乘法运算，所有的乘法运算它最终都是再指令层面转化为了加法实现的，这样效率很低，如果用位运算的话对cpu来说就非常的简洁高效。

负载因子：
给定的默认容量为 16，负载因子为 0.75。Map 在使用过程中不断的往里面存放数据，当数量达到了 16 * 0.75 = 12 就需要将当前 16 的容量进行扩容，而扩容这个过程涉及到 rehash、复制数据等操作，所以非常消耗性能。
因此通常建议能提前预估 HashMap 的大小最好，尽量的减少扩容带来的性能损耗。

#### 为什么HashMap的默认负载因子是0.75，而不是0.5或者是整数1呢？
阈值(threshold) = 负载因子(loadFactor) x 容量(capacity) 
根据HashMap的扩容机制，他会保证容量(capacity)的值永远都是2的幂 为了保证负载因子x容量的结果是一个整数，这个值是0.75(4/3)比较合理，因为这个数和任何2的次幂乘积结果都是整数。

    
#### HashMap如何解决散列碰撞（必问）？
拉链法

学习相关资料：

https://blog.csdn.net/weixin_34254823/article/details/94558911?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control&dist_request_id=e6fd92ca-31c8-4dd3-b6d6-72987bf58a8d&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control
https://blog.csdn.net/xiewenfeng520/article/details/107119970


https://blog.csdn.net/qq_41097354/article/details/90515802?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control&dist_request_id=1328575.12942.16146763705021871&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control


#### 为什么不使用二叉查找树，而是使用红黑树？
二叉查找树很可能会造成一条线性结构，就会变成和链表一样的结构了，遍历查找就会非常慢。
而红黑树在插入新数据后可能需要通过左旋，右旋、变色这些操作来保持平衡，引入红黑树就是为了查找数据快，解决链表查询深度的问题，
我们知道红黑树属于平衡二叉树，但是为了保持“平衡”是需要付出代价的，但是该代价所损耗的资源要比遍历线性链表要少，所以当长度大于8的时候，会使用红黑树，如果链表长度很短的话，根本不需要引入红黑树，引入反而会慢。

https://blog.csdn.net/weixin_39819661/article/details/111249224















