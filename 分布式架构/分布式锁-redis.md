#### 一般实现分布式锁都有哪些方式？
redis,zookeeper

#### 使用 redis 如何设计分布式锁？

RedLock 算法，是 redis 官方支持的分布式锁算法。

##### redis 最普通的分布式锁:

在 redis 里使用 setnx 命令创建一个 key
````
命令：
SET resource_name random_value NX PX 30000

resource_name:KEY
random_value:VALUE 设置一个随机值 如 时间戳
NX:表示只有 key 不存在的时候才会设置成功。（如果此时 redis 中存在这个 key，那么设置失败，返回 nil）
PX 30000：意思是 30s 后锁自动释放。别人创建的时候如果发现已经有了就不能加锁了。
````
释放锁：
就是删除 key ，但是一般可以用 lua 脚本删除，判断 value 一样才删除：
````
-- 删除锁的时候，找到 key 对应的 value，跟自己传过去的 value 做比较，如果是一样的才删除。
if redis.call("get",KEYS[1]) == ARGV[1] then
    return redis.call("del",KEYS[1])
else
    return 0
end
````
为啥要用 random_value 随机值呢？
````
因为如果某个客户端获取到了锁，但是阻塞了很长时间才执行完，比如说超过了 30s，
此时可能已经自动释放锁了，此时可能别的客户端已经获取到了这个锁，要是你这个时候直接删除 key 的话会有问题，
所以得用随机值加上面的 lua 脚本来释放锁。
````

##### redis中 RedLock 算法
````
当我们是redis主从架构模式的时候，redis主从异步复制还没完成的时候，主节点挂了，那么我们上的分布式redis锁就没有了，
key还没有同步到从节点，那么此时从节点切换为主节点，其他线程就能set key ，从而拿到锁。
RedLock 算法就是尽可能的减少这种情况发生。
这个场景是假设有一个 redis cluster（集群），有 5 个 redis master 实例。然后执行如下步骤获取一把锁：

1. 获取当前时间戳，单位是毫秒；
2. 跟上面类似，轮流尝试在每个 master 节点上创建锁，过期时间较短，一般就几十毫秒；
3. 尝试在大多数节点上建立一个锁，比如 5 个节点就要求是 3 个节点 n / 2 + 1；
4. 客户端计算建立好锁的时间，如果建立锁的时间小于超时时间，就算建立成功了；
5. 要是锁建立失败了，那么就依次之前建立过的锁删除；
6. 只要别人建立了一把分布式锁，你就得不断轮询去尝试获取锁。
````




























