#### redis 的线程模型是什么？为什么 redis 单线程却能支撑高并发？
1. 纯内存操作。
2. 核心是基于非阻塞的 IO 多路复用机制。
3. 单线程反而避免了多线程的频繁上下文切换问题，预防了多线程可能产生的竞争问题。
4. C 语言实现，一般来说，C 语言实现的程序“距离”操作系统更近，执行速度相对会更快。

https://www.processon.com/view/link/604f75741e0853179f5e8a34

#### redis都有哪些数据类型？分别在哪些场景下使用比较合适呢？
数据类型：
1. string
2. hash
3. list
4. set
5. sorted set(排序)

#### redis 的过期策略都有哪些？内存淘汰机制都有哪些？手写一下 LRU 代码实现？
redis 内存淘汰机制有以下几个：
1. noeviction: 当内存不足以容纳新写入数据时，新写入操作会报错，这个一般没人用吧，实在是太恶心了。
2. allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）。
3. allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个 key，这个一般没人用吧，为啥要随机，肯定是把最近最少使用的 key 给干掉啊。
4. volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的 key（这个一般不太合适）。
5. volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个 key。
6. volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的 key 优先移除。


LRU代码实现：
可以考虑LinkedHashMap数据结构。

#### 如何保证 redis 的高并发和高可用？redis 的主从复制原理能介绍一下么？redis 的哨兵原理能介绍一下么？

#### redis 的持久化有哪几种方式？不同的持久化机制都有什么优缺点？持久化机制具体底层是如何实现的？
redis 持久化的两种方式
RDB：RDB 持久化机制，快照，是对 redis 中的数据执行周期性的持久化。
AOF：AOF 机制对每条写入命令作为日志，以 append-only 的模式写入一个日志文件中，在 redis 重启的时候，可以通过回放 AOF 日志中的写入指令来重新构建整个数据集。
    注意：因为AOF存放的是每条写入命令的，但是我们redis本身内存是有限制的，比如只能存放10G的数据，AOF文件会到一定时候作一次rewrite操作，
        AOF的rewrite操作会基于当时的redis内存中的数据来重新构建一个新的更小的AOF文件，然后将旧的AOF文件删除。

如果同时使用 RDB 和 AOF 两种持久化机制，那么在 redis 重启的时候，会使用 AOF 来重新构建数据，因为 AOF 中的数据更加完整。


RDB：速度快，每隔默认5分钟会生成一份快照数据，恢复数据快可以直接使用。但是会有5分钟之内的数据丢失的可能性。
AOF：可以更好保护数据不丢失，一般每隔1秒就会把命令写入磁盘，文件不容易损坏。但是文件会持续增长，恢复数据时间较长。


#### 如何保证缓存与数据库的双写一致性？
读的时候，先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应。
更新的时候，先更新数据库，然后再删除缓存。

#### redis 主从复制理解
https://www.processon.com/view/link/6050a999f346fb348a95a1bb

#### redis哨兵机制理解
1. 哨兵至少需要三个实例，来保证自己的健壮性
2. 哨兵+redis主从的部署架构，是不会保证数据的零丢失的，只能保证redis集群的高可用
3. 对于哨兵+redis主从复杂的部署架构，尽量在测试生产环境进行充足的测试。
#### redis哨兵主备切换的数据丢失问题
异步复制、集群脑裂

解决方式：
redis配置这两个参数，减少数据丢失：
min-slaves-to-write 1
min-slaves-max-lag 10

至少有一个 slave ，数据复制和同步直接的延迟不能超过10秒。
一旦超过10秒，让master不会接收任何请求。

#### redis哨兵的多个核心底层原理

#### 怎么保证redis是高并发以及高可用的？

主从架构 （一主多从）来达到高并发

主从架构 + 哨兵机制部署 来达到高可用




















