#### java 线程在运行周期的6种状态？
````
Thread.java 类中 enum State 规定了
public enum State {
        NEW,
        RUNNABLE,
        BLOCKED,
        WAITING,
        TIMED_WAITING,
        TERMINATED;
    }

````
#### 画一下线程流转图？

https://www.processon.com/view/link/60d6e63d1e08532a43be80c4

#### 了解死锁
多个线程相互持有对方所需要的资源，导致线程一直等待下去无法执行。就进入死锁状态。
````
死锁条件：
1. 互斥，共享资源 X 和 Y 只能被一个线程占用；
2. 占有且等待，线程01 已经取得共享资源 X，在等待共享资源 Y 的时候，不释放共享资源 X；
3. 不可抢占，其他线程不能强行抢占线程01 占有的资源；
4. 循环等待，线程01 等待线程02 占有的资源，线程02 等待线程01 占有的资源，就是循环等待。
避免死锁：
1. 一次性申请所有的资源，也就是一次性占用 X和 Y两个资源。
2. 设置占用时间,到了时间自动释放锁。lock1.tryLock(1, TimeUnit.MILLISECONDS)
3. 资源有序分配法
````

#### Notify() 和 notifyAll() 这两者区别？
notify() 是会随机地通知等待队列中的任意一个线程，而 notifyAll() 会通知等待队列中的所有线程。
觉得 notify() 会更好一些的同学可能认为即便通知所有线程，也只有一个线程能够进入临界区。但是实际上使用 notify() 也很有风险，因为随机通知等待的线程，可能会导致某些线程永远不会被通知到。
所以除非经过深思熟虑，否则尽量使用 notifyAll()。










