#### MySQL中MyISAM和InnoDB存储引擎的区别是啥？
myisam：不支持事务，不支持外键约束，索引文件和数据文件分开，这样在内存里可以缓存更多的索引，对查询的性能会更好，适用于那种少量的插入，大量查询的场景。
innodb：主要特点就是支持事务，走聚簇索引，强制要求有主键，支持外键约束，高并发、大数据量、高可用等相关成熟的数据库架构，分库分表、读写分离、主备切换，

#### MySQL的索引实现原理？各种索引你们平时都怎么用的？

B+树，

#### B+树和B-树的区别？
````
b+树跟b-树不太一样的地方在于：
1.B+每个节点的指针上限为2d而不是2d+1。
2.B+内节点不存储data，只存储key； 叶子节点不存储指针。
````

#### 事务的几个特性是啥？有哪几种隔离级别?

```
1.事务的ACID
    1.1 Atomic 原子性
    1.2 Consistency 一致性
    1.3 lsolation   隔离性
    1.4 Durability  持久性
2.事物的隔离级别
    2.1 读未提交，问题会出现脏读，读取到的数据可能是事务还没有提交的数据。
                解决：将数据库隔离级别修改为READ COMMITTED 读已提交。只能读取提交事务的数据即可。在mysql数据库中读取的是事务版本号比自己小的数据。
    2.2 读已提交 不可重复读，问题会出现 不可重复读，幻读，在事务进行中，重复读取统一条记录，显示的数据不同，称为不可重复读。
                原因 出现不可重复读是因为在对数据进行修改的时候，会产生 undo log,在 undo log中，数据会有多个版本的快照数据，在这个事务级别下，innodb每次读取的历史版本是最新的版本数据，
                     因此，每当有新的事务提交产生新的版本数据时，该事务隔离级别读取到的数据会发生不一致这种现象（每次select会产生一个新的 readView 导致。）
                    出现幻读是因为在事务执行 select 操作加锁时，仍然可以进行insert 操作对数据进行修改，再次select操作得到的结果不一致的问题，因为在该事务级别
                    下不支持间隙锁，当select加锁只能对当前记录本身的索引值加锁，不能对范围进行加锁，以致于可以继续插入范围内的数据造成了幻读。
                解决：这个跟ReadView相关，每次select会生成一个新的ReadView，所以造成多次查询结果数据不一致。将隔离级别修改为REPEATABLE READ 可重复读,
                     因为在这个级别下，每次select时总是查询事务开始时的数据版本，即每次事务开始时都会生成一份独立的ReadView，直到事务结束都用这一份ReadView，也就读取的都是事务开始时的数据。
                     在innodb存储引擎的RR级别，由于运用了间隙锁（不仅会对主键唯一索引加锁，同时也会对行记录中的辅助索引加锁），所以可以解决幻读的问题。    
    2.3 可重复读 Mysql innodb默认隔离级别,解决了读已提交的的问题。
    2.5 串行化，序列化 ，事务级别最高，一个事务完成后，另一个事务才能开始。

MySQL是通过MVCC机制来实现，就是多版本并发控制，multi-version concurrency control。

```
#### mysql数据库锁
````
主要是
行锁： innodb 行锁有共享锁（S）和排他锁（X），
表锁： innodb 表锁分为：
             意向共享锁,就是加共享行锁的时候，必须先加这个共享表锁.
             意向排他锁,就是加排他锁的时候，必须先加排他锁.

增删改的时候，innodb会自动给那一行加行级排他锁
查询的时候，innodb默认实现了可重复读，也就是MVCC机制，

innodb 手动加锁：
共享锁：select * from a where id = 1 lock in share mode.这样其他事务就不能来修改这行数据。
排他锁：select * from a where id = 1 for update.这个要注意使用。

````
#### 悲观锁和乐观锁

```
悲观锁：拿到数据后加一把锁，别人无法操作这个数据，只有我自己可以操作，类似于 select * from a where id = 1 for update 这样。加了悲观锁后就不能加其他任何锁.
乐观锁：一般是用版本号控制。拿到数据后，每次修改前会拿版本号和数据库中的版本号对比，一样的就能修改，并且把版本号加1.
```
#### 死锁
相互锁，会导致死锁。

























