#### MySQL中MyISAM和InnoDB存储引擎的区别是啥？
myisam：不支持事务，不支持外键约束，索引文件和数据文件分开，这样在内存里可以缓存更多的索引，对查询的性能会更好，适用于那种少量的插入，大量查询的场景。
innodb：主要特点就是支持事务，走聚簇索引，强制要求有主键，支持外键约束，高并发、大数据量、高可用等相关成熟的数据库架构，分库分表、读写分离、主备切换，

#### MySQL的索引实现原理？各种索引你们平时都怎么用的？

B+树，

#### B+树和B-树的区别？
````
b+树跟b-树不太一样的地方在于：
1.B+每个节点的指针上限为2d而不是2d+1。
2.B+内节点不存储data，只存储key； 叶子节点不存储指针。
````

#### 事务的几个特性是啥？有哪几种隔离级别?

```
1.事务的ACID
    1.1 Atomic 原子性
    1.2 Consistency 一致性
    1.3 lsolation   隔离性
    1.4 Durability  持久性
2.事物的隔离级别
    2.1 读未提交，脏读
    2.2 读已提交，
    2.3 可重复读 Mysql默认隔离级别
    2.4 幻读
    2.5 串行化 解决幻读

MySQL是通过MVCC机制来实现，就是多版本并发控制，multi-version concurrency control。

```
#### mysql数据库锁
````
主要是
行锁： innodb 行锁有共享锁（S）和排他锁（X），
表锁： innodb 表锁分为：
             意向共享锁,就是加共享行锁的时候，必须先加这个共享表锁.
             意向排他锁,就是加排他锁的时候，必须先加排他锁.

增删改的时候，innodb会自动给那一行加行级排他锁
查询的时候，innodb默认实现了可重复读，也就是MVCC机制，

innodb 手动加锁：
共享锁：select * from a where id = 1 lock in share mode.这样其他事务就不能来修改这行数据。
排他锁：select * from a where id = 1 for update.这个要注意使用。

````
#### 悲观锁和乐观锁

```
悲观锁：拿到数据后加一把锁，别人无法操作这个数据，只有我自己可以操作，类似于 select * from a where id = 1 for update 这样。加了悲观锁后就不能加其他任何锁.
乐观锁：一般是用版本号控制。拿到数据后，每次修改前会拿版本号和数据库中的版本号对比，一样的就能修改，并且把版本号加1.
```
#### 死锁
相互锁，会导致死锁。

























